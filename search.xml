<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue2.0 探索之生命周期与钩子函数]]></title>
    <url>%2F2017%2F12%2F13%2Fvue2.0-life-cycle%2F</url>
    <content type="text"><![CDATA[官网在介绍生命周期的时候，给出了图示，并且说你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。第一次看图的时候，简单浏览。后面找到一些实际项目来看发现钩子函数的定义十分常见，而自己对于钩子函数是哪个阶段起作用认识很模糊，便回头重新理解生命周期图，遂有此文。 生命周期 Vue1.0+ Vue2.0 描述 init beforeCreate 组件实例刚被创建，组件属性计算之前，如data属性 created created 组件实例创建完成，属性已绑定，但DOM还未生成，$el属性还不存在 beforeCompile beforeMount 模板编译/挂载之前 compiled mounted 模板编译/挂载之后 ready mounted 模板编译/挂载之后 – beforeUpdate 组件更新之前。数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。 – updated 组件更新之后，由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。 – activated keep-alive 组件被激活时调用 – deactivated keep-alive 组件停用时调用 attached – 弃用了 detached – 弃用了 beforeDestory beforeDestory 实例销毁前调用，实例仍然完全可用 destoryed destoryed 实例销毁之后 辅助实例下面我们结合实例对于生命周期的各个阶段进一步理解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var app = new Vue(&#123; el: '#app', data: &#123; message: "A Vue example." &#125;, beforeCreate: function() &#123; console.group('beforeCreate 创建前状态===============》'); console.log("%c%s", "color:red", "el : " + this.$el); //undefined console.log("%c%s", "color:red", "data : " + this.$data); //undefined console.log("%c%s", "color:red", "message: " + this.message) &#125;, created: function() &#123; console.group('created 创建完毕状态===============》'); console.log("%c%s", "color:red", "el : " + this.$el); //undefined console.log("%c%s", "color:red", "data : " + this.$data); //已被初始化 console.log("%c%s", "color:red", "message: " + this.message); //已被初始化 &#125;, beforeMount: function() &#123; console.group('beforeMount 挂载前状态===============》'); console.log("%c%s", "color:red", "el : " + (this.$el)); //已被初始化 console.log(this.$el); console.log("%c%s", "color:red", "data : " + this.$data); //已被初始化 console.log("%c%s", "color:red", "message: " + this.message); //已被初始化 &#125;, mounted: function() &#123; console.group('mounted 挂载结束状态===============》'); console.log("%c%s", "color:red", "el : " + this.$el); //已被初始化 console.log(this.$el); console.log("%c%s", "color:red", "data : " + this.$data); //已被初始化 console.log("%c%s", "color:red", "message: " + this.message); //已被初始化 &#125;, beforeUpdate: function() &#123; console.group('beforeUpdate 更新前状态===============》'); console.log("%c%s", "color:red", "el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red", "data : " + this.$data); console.log("%c%s", "color:red", "message: " + this.message); &#125;, updated: function() &#123; console.group('updated 更新完成状态===============》'); console.log("%c%s", "color:red", "el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red", "data : " + this.$data); console.log("%c%s", "color:red", "message: " + this.message); &#125;, beforeDestroy: function() &#123; console.group('beforeDestroy 销毁前状态===============》'); this.message="456"; console.log("%c%s", "color:red", "el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red", "data : " + this.$data); console.log("%c%s", "color:red", "message: " + this.message); &#125;, destroyed: function() &#123; console.group('destroyed 销毁完成状态===============》'); this.message="123"; console.log("%c%s", "color:red", "el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red", "data : " + this.$data); console.log("%c%s", "color:red", "message: " + this.message) &#125;&#125;) 将代码保存为hook.html，拖入浏览器运行，在控制台看到以下信息： create和mounted beforeCreate el与data都未初始化； created data初始化完成，el仍未初始化； beforeMount el初始化，但el中的元素&lt;p&gt;&lt;/p&gt;，节点已产生，但message还没有渲染进去。 mounted el初始化完成，message完成渲染。 update 在控制台更新app.message触发beforeUpdate与updated钩子函数，beforeUpdate时，el中的message就已经替换成了更改之后的。 destory 分别在beforeDestroyed与destroyed钩子函数中更改message的内容，打印出来的结果显示message可以更改，但没有触发update的动作，DOM没有重新渲染。在Vue实例被销毁后，实例不存在了，对message的更改是无效的。 使用总结 beforeCreate： 这时data\watcher\methods都是没有的。只有$route对象是存在的，可以根据路由进行重定向之类的操作。 created：在这步，实例已完成了数据观测，属性和方法的运算，watch/event事件毁掉。$el属性目前不可见。可向后台接口发送数据请求，根据返回改变data。 beforeMount： render函数首次被调用，页面渲染时所需的数据，要尽量在这阶段之前完成赋值。 mounted：创建vm.$el并替换el，挂载到实力上。依赖于DOM的代码放在这里，比如监听DOM事件。 beforeUpdate：虚拟DOM重新渲染和打补丁之前被调用。可在这里进一步修改$vm.data。 updated：可以继续执行依赖DOM的操作。 beforeDestroy：在这里实例仍然可用，没想好有什么特别的可以放在这里操作。 destroyed: 实例删除之后，给提示。]]></content>
      <categories>
        <category>技术</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular Schema Form使用方法]]></title>
    <url>%2F2017%2F11%2F15%2Fangular-schema-form-example%2F</url>
    <content type="text"><![CDATA[完成功能这是一种支持多种元素的表单，包括下拉框，编辑器，日期选择器，颜色选择器等。Angular Schema Form是分schema，form,data三块Json去定义表单。在controller里面，schema定义了数据结构，form定义了UI，model绑定了用户的输入。在html中使用统一的写法，使用ng-schema，ng-form与ng-model指令分别绑定，最后可呈现出不同的表单。 环境配置 先通过npm下载项目，使用指令npm install angular-schema-form，找到项目中的dist文件夹，拿到压缩文件bootstrap-decorator.min.js与schema-form.min.js。 把压缩文件bootstrap-decorator.min.js与schema-form.min.js放入项目alogic-itportal-web的lib文件夹下。压缩文件放在lib文件夹下将在发布时保持原有格式，不会被压缩。 参考angular-schema-form的用户手册，需要引入其他js文件，https://github.com/json-schema-form/angular-schema-form， 且需要按照一定的顺序加载，需要按照以下顺序：angular.min.js， angular-sanitize.min.js， tv4.js ，ObjectPath.js，schema-form.min.js，bootstrap-decorator.min.js。 在使用到表单的入口，manage.js与app.js中分别载入schema-form模块，var app = angular.module(&#39;app&#39;, [&#39;schemaForm&#39;,&#39;jscross&#39;, &#39;ui.router&#39;, &#39;slick&#39;, &#39;pasp.ui&#39;]);。 在itportal中的应用在itportal的manage入口，实现了用户/岗位/机构/团队的新建以及编辑更新的功能，这里大量使用了表单，下面用新建团队作为例子，分directive/controller/tpl三部分来说明schema-form的使用方法。 directive123456789jscross.widget('newTeam', &#123; templateUrl: relativePath.plugin + 'manage/template/team/new.team.tpl.html', replace: false, restrict: 'A', controller: 'newTeamCtrl', scope: &#123; current: '=' &#125;&#125;); 分别绑定了模板和控制器，没有太多需要解释。 controller中的formcontroller中的form定义，form是定义了UI，这里是说在表单中会显示有三个元素id，name和note，像name这样没有附加其他属性的，就是最基本的输入框，placeholder是显示在输入框的提示语，在定义id的时候，要判断id是否已占用，这里需要到服务器进行异步验证。123456789101112131415161718192021222324252627282930$scope.form = [&#123; 'key': 'id', 'placeholder': '字母数字特殊字符下划线的组合，长度大于3小于16', '$asyncValidators': &#123; IdAlreadyTaken: function(value) &#123; var deferred = $q.defer(); //通过$q服务注册一个延迟对象deffered if(value != undefined) &#123; var IdOkcallback = function(data) &#123; deferred.resolve(); &#125; var IdExistCallback = function(data) &#123; deferred.reject(); &#125; team.IdCheck(&#123; id: value &#125;, IdOkcallback, IdExistCallback); &#125; return deferred.promise; //promise返回当前任务的完成结果 &#125; &#125;, 'validationMessage':&#123; 'IdAlreadyTaken': 'ID已经被注册！' &#125;&#125;,'name', &#123; 'key': 'note', 'type': 'textarea', 'placeholder': '简单介绍你的团队吧'&#125;]; 异步校验$q是Angular的一种内置服务，它可以使你异步地执行函数，并可以获取到函数的返回值。 deferred.resolve(value) 成功解决(resolve)了其派生的promise。参数value将来会被用作promise.then(successCallback(value){...}, errorCallback(reason){...},notifyCallback(notify){...})中successCallback函数的参数。 deferred.reject(reason) 未成功解决其派生的promise。参数reason被用来说明未成功的原因。此时deferred实例的promise对象将会捕获一个任务未成功执行的错误，promise.catch(errorCallback(reason){...})。补充一点，promise.catch(errorCallback)实际上就是promise.then(null, errorCallback)的简写。异步校验注意事项 需要注意的是$asynValidators中校验函数的名称与validationMessage中错误码中的名称一致，这里都是IdAlreadyTaken。在页面输入完id之后会将value传入IdAlreadyTaken方法，调用后台的IdCheck服务，如果没有占用则在界面上显示对号，如果已占用则在页面显示叉号并提示“ID已经被注册”。 controller中的schema与data123456789101112131415161718192021222324252627$scope.dataModel = &#123;&#125;;$scope.schema = &#123; &apos;type&apos;: &apos;object&apos;, &apos;title&apos;: &apos;new-team&apos;, &apos;properties&apos;: &#123; &apos;id&apos;: &#123; &apos;title&apos;: &apos;ID&apos;, &apos;type&apos;: &apos;string&apos;, &apos;pattern&apos;: &apos;^[a-zA-Z0-9._-]&#123;3,&#125;$&apos; &#125;, &apos;name&apos;: &#123; &apos;title&apos;: &apos;名称&apos;, &apos;type&apos;: &apos;string&apos; &#125;, &apos;note&apos;: &#123; &apos;title&apos;: &apos;简介&apos;, &apos;type&apos;: &apos;string&apos;, &apos;maxLength&apos;: &apos;70&apos;, &apos;validationMessage&apos;: &apos;太长啦，装不下啦&apos; &#125; &#125;, &apos;required&apos;: [ &apos;id&apos;, &apos;name&apos; ]&#125;; schema定义了数据结构，其中properties定义了元素，这里的元素与form中的元素（或form中元素的key）是对应的，包括id,name与note，事实上在最后生成的dataModel中包含的也是这三个属性。title是显示在界面上的输入框前的label，pattern是用正则表达式检验输入内容，可以规定输入域的长度，以及定义提示信息。required表示必须要填的元素，没有填就提交时会报错。在schema-form中，有些元素是有多种实现形式的，比如下拉框有三种实现形式，通过schema和form共同来实现。由于是新建team，dataModel在这里初始化为空，如果是更新团队等表单，则dataModel要用已有的团队信息进行初始化。 controller中表单的提交12345678$scope.OK = function(form) &#123; // First we broadcast an event so all fields validate themselves $scope.$broadcast('schemaFormValidate'); // Then we check if the form is valid if(form.$valid) &#123; newTeam(); &#125;&#125;; 通过broadcast一个事件（schemaFormValidate）来强制执行校验，校验成功form.$valid为true时，执行新建团队的方法。 表单的模板12345678910111213&lt;div class="panel panel-default"&gt; &lt;div class="panel-body"&gt; &lt;div class="col-md-8"&gt; &lt;div&gt; &lt;form name="newTeamForm" sf-model="dataModel" sf-schema="schema" sf-form="form" sf-options="&#123; formDefaults: &#123; ngModelOptions: &#123; updateOn: 'blur' &#125; &#125;&#125;"&gt;&lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col-md-8" style="text-align:center;"&gt; &lt;button class="btn btn-default btn-success margin-right-20" type="submit" ng-click="OK(newTeamForm)"&gt;完成&lt;/button&gt; &lt;button class="btn btn-default" type="submit" ng-click="cancel()"&gt;取消&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 这里双向绑定dataModel/schema/form，SchemaForm通过sf-options来设定全局属性，sf-options=&quot;{ formDefaults: { ngModelOptions: { updateOn: &#39;blur&#39; } }}&quot;此设置会使表单的每项都带上一个属性：ng-model-options=”form.ngModelOptions”，关于ng-model-options：常用于将“model与用户输入实时同步”改为“model在用户输入完（blur之后）再同步”。 参考网站官网：http://schemaform.io/ git地址：https://github.com/json-schema-form/angular-schema-form demo地址：http://schemaform.io/examples/bootstrap-example.html 资料参考地址：http://www.cnblogs.com/natsu12/p/5417092.html]]></content>
      <categories>
        <category>技术</category>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
        <tag>widget</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas动画实例初探]]></title>
    <url>%2F2017%2F11%2F14%2Fcanvas-example%2F</url>
    <content type="text"><![CDATA[运维门户中心是一个集组织管理、应用管理、栏目订阅等功能的综合平台，登录界面一直比较朴素，为了美化登录界面需要选取背景。参考了一些线上门户的登录背景，比如Google的背景是用svg写的，知乎是用canvas写的。比较起来，canvas写的动画视觉效果更好，决定学习下知乎背景的写法。 整体思路获取画布渲染上下文，生成制定个数的随机坐标点，给每个点不同的初始速度使之运动。在两两点之间建立联系，给连线一个透明度值，使两点越近连线越明显，以符合日常生活经验。根据速度改变坐标，遇到屏幕边界时，做穿越或碰撞处理。在浏览器重绘之前更新画布。 核心分解html内容只有一行&lt;canvas id=&quot;myCanvas&quot;&gt;&lt;/canvas&gt;，&lt;canvas&gt; 是 HTML5 新增的元素，可通过JavaScript脚本来绘制图形。它的用途广泛，可用于绘制图形，制作照片，创建动画，甚至可以进行实时视频处理或渲染。下面来分解js的内容。 canvas基础&lt;canvas&gt;标签只有两个属性，width与height，这里通过DOM properties设置了宽度和高度。canvas起初是空白的，为了展示，脚本要先找到渲染上下文（the rendering context），然后在它上面绘制。&lt;canvas&gt;元素的getContext()方法是用来获取渲染上下文和它的绘画功能，传入的参数”2d”是上下文的格式。 接下来是定义圆形的半径，取[5,20]范围，初始位置在不出画布的前提下随机，初始水平速度与垂直速度在[-0.4,0.4]范围内。代码如下：12345678910111213141516171819202122232425262728var w = window.innerWidth;var h = window.innerHeight;var canvas = document.getElementById("myCanvas");var ctx = canvas.getContext("2d");var allRound = [];var dxdy = [];//设置画布宽高与窗口宽高一样canvas.width = w;canvas.height = h;function fnRandom(min, max) &#123; return parseInt((max - min) * Math.random() + min + 1);&#125;function Round() &#123; this.r = fnRandom(5, 20); this.diam = this.r * 2; //随机位置 var x = fnRandom(0, canvas.width - this.r); this.x = x &lt; this.r ? this.r : x; var y = fnRandom(0, canvas.height - this.r); this.y = y &lt; this.r ? this.r : y; //随机速度 var speed = fnRandom(2, 4) / 10 this.speedX = fnRandom(0, 4) &gt; 2 ? speed : -speed; this.speedY = fnRandom(0, 4) &gt; 2 ? speed : -speed; //颜色 this.color = "#ECEEEF";&#125; 路径绘制的方法Round有两个方法draw与move，draw方法是绘制圆形，这里介绍下使用路径绘制图形的步骤： 首先，创建路径的起始点。 使用画图命令画出路径。 把路径封闭。 可通过描边或填充路径区域来渲染图形。 以下是用到的函数： beginPath()新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。 closePath()闭合路径之后图形绘制命令又重新指向到上下文中。 stroke()通过线条来绘制图形轮廓。 fill()通过填充路径的内容区域生成实心的图形。 move方法是圆形从现有坐标上移动一个水平和垂直位移。提供圆形到达画布边界的处理方案：如果圆形碰到右侧边界，则水平速度取反向，模拟碰撞反弹的效果；如果圆形碰到左侧边界，则将圆形置于画布右侧，模拟圆形穿过左侧边界的效果。画布的下边界与上边界也分别模拟碰撞反弹与穿越效果。代码如下： 12345678910111213141516171819202122Round.prototype.draw = function() &#123; //绘制函数 ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2, true); ctx.closePath(); ctx.fill();&#125;Round.prototype.move = function() &#123; this.x += this.speedX; if(this.x &gt; canvas.width - this.r) &#123; this.speedX *= -1; &#125; else if(this.x &lt; this.r) &#123; this.x = canvas.width - this.r; &#125; this.y += this.speedY; if(this.y &gt; canvas.height - this.r) &#123; this.speedY *= -1; &#125; else if(this.y &lt; this.r) &#123; this.y = canvas.height - this.r; &#125;&#125; 动画基本步骤roundMove()是核心部分，是它让动画动了起来，先看下动画的基本步骤： 清空canvas 这里用clearRect方法实现。 保存canvas状态 如果你要改变一些会改变canvas状态的设置，又要在每画一帧之时都是原始状态则要先保存。 绘制动画图形 这一步是重绘动画帧。这里用到的是window.requestAnimationFrame(callback),这个方法提供了平缓有效率的方式执行动画，当系统准备好重绘条件的时候次啊会调用绘制动画帧，在重绘之前浏览器执行函数roundMove。 恢复canvas状态 如果已保存了canvas状态，可以先恢复，再重绘下一帧。 12345678910111213141516171819202122232425262728293031323334353637383940//使用Roundfunction initRound() &#123; //初始化20个圆形对象,放到数组中 for(var i = 0; i &lt; 20; i++) &#123; var obj = new Round(); allRound.push(obj); &#125;&#125;initRound();function roundMove() &#123; ctx.clearRect(0, 0, canvas.width, canvas.height); //遍历所有的圆形对象,让对象自己重绘,移动 for(var i = 0; i &lt; allRound.length; i++) &#123; var round = allRound[i]; round.draw(); round.move(); dxdy[i] = &#123; dx: round.x, dy: round.y &#125;; var dx = dxdy[i].dx; var dy = dxdy[i].dy; for(var j = 0; j &lt; i; j++) &#123; var sx = dxdy[j].dx; var sy = dxdy[j].dy; var l = Math.sqrt((dx - sx) * (dx - sx) + (dy - sy) * (dy - sy)); var C = 1 / l * 7 - 0.009; var o = C &gt; 0.03 ? 0.03 : C; ctx.strokeStyle = 'rgba(0,0,0,' + o + ')'; ctx.beginPath(); ctx.lineWidth = 2; ctx.moveTo(dxdy[i].dx, dxdy[i].dy); ctx.lineTo(dxdy[j].dx, dxdy[j].dy); ctx.closePath(); ctx.stroke(); &#125; &#125; window.requestAnimationFrame(roundMove);&#125;roundMove(); roundMove()中逐个生成圆形，且和在此之前生成的圆形两两之间连线，连线为黑色，rgba的最后一个参数用来设置透明度。如果不设置透明度，则默认透明度为1，则可以看到所有的连线。这里计算了两个圆形之间的距离l，透明度设置在(0,0.03]之间。距离越大，透明度越高，连线就越不清晰。距离一定远之后，看起来两个圆形就是离散的了。连线使用的就是路径绘制的方法。最后实现的效果，可以在运维门户中心的登录页面看到，传送门： http://10.142.90.58:9092/#/ 参考资料 一个很好的canvas教程：https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API w3cSchool的canvas教程：http://www.w3school.com.cn/jsref/dom_obj_canvas.asp 事实上，知乎的登录页背景是直接用了particles.js库实现的，下面是相关教程： particles的demo：https://codepen.io/VincentGarreau/pen/pnlso particles的github：https://github.com/VincentGarreau/particles.js]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
</search>
